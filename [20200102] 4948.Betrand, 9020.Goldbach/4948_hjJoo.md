# 소수 구하기 알고리즘
* <b> 부제1: 소수 구할 때 실행횟수 절약하기 </b>
* <b> 부제2: 에라토스테네스의 체를 이용하지 않고 소수 알고리즘 짜기 </b> 
- - - -
#### Step1. 기존의 소수 여부 확인 알고리즘
<pre>
bool prime[100];                            // 각 수들이 소수인지 여부를 저장하는 배열
bool isPrime;
for(i=2; i<100; i++){
        isPrime = true;
        for(j=2; j<i; j++){
            if(i%j==0) isPrime=false; 
        }
        prime[i]=isPrime;
}
</pre>
* 위와 같이 구하려고 하는 값(i)이 있을 때, i보다 작은 값까지 돌면서 나누어지는 값이 있는 지 확인 후 없으면 소수이다.
* 그런데 위와 같은 경우로 확인할 경우,
  -> ex) i=16이라면 j=2,4,8 이렇게 세 번의 경우에서 조건문에 걸리게 된다. <b>8을 확인하는 게 의미가. 있을까?</b>
- - - -
#### Step2. 제곱근까지만 확인하자!
* 모든 약수들은 짝을 갖는다. 예를 들어 24라면, 1*24, 2*12, 3*8, 4*6, ... 그렇기 때문에 앞의 일정 부분까지. 확인을 하고 나면 뒤의 부분은 확인하는 것이 무의미해진다.
  => 그럼 여기서 <b>"일정 부분"</b>이란 어디까지일까? 이것을 약수의 교차점이라고 하자.
  => 약수의 교차점은 바로 <b>제곱근</b>까지이다. 아래를 살펴보자
<pre>
  4  :  1 2 4
  6  :  1 2 3 6 (6의 제곱근은 약 2.45)
  9  :  1 3 9
  12  :  1 2 3 4 6 12 (12의 제곱근은 약 3.46)
  36  :  1 2 3 4 6 9 12 18 36
</pre>
* 즉, 약수의 유무를 확인할 때 제곱근까지만 확인하면 이후의 수는 의미가 없다. 따라서 코드는 아래와 같이 작성된다. (이 때 주의할 점은 반복문을 돌 때 제곱근을 "포함"해야 한다는 것이다.
<pre>
bool prime[100];
bool isPrime;
for(i=2; i<n; i++){
        isPrime = true;
        for(j=2; j<=sqrt(i); j++){
            if(i%j==0) isPrime=false; 
        }
        prime[i]=isPrime;
}
</pre>
* 위와 같이 제곱근까지 반복문을 돌게 된다면 절반 이상으로 실행 횟수가 줄어든다. 12의 경우 기존에는 j가 2부터 11까지 순회하던 것이 3까지만 가기 때문에 4부터 11까지, 즉 10번 중 8번의 실행 횟수를 줄일 수 있다. 
- - - -
#### Step3. 그 외 소소한 팁들
* Step2까지만 진행해도 충분히 실행횟수를 많이 줄일 수 있다. 만약 당신이 만족하지 않고 조금 더 효율을 내고 싶다면 하나 더 생각해보자. 바로 <b>2를 제외한 짝수 중에 "소수"는 없다는 것</b>
* 즉, 2를 제외한 짝수가 소수인지 여부를 확인하는 것은 <b>무의미하다.</b> 그러므로 코드를 수정하면,
<pre>
bool prime[100];
bool isPrime;
prime[2]=true;
for(i=3; i<n; i+=2){
        isPrime = true;
        for(j=2; j<=sqrt(i); j++){
            if(i%j==0) isPrime=false; 
        }
        prime[i]=isPrime;
}
</pre>
* 기존의 i가 2, 3, 4, 5, ... 로 순회했다면 위의 코드는 3, 5, 7, 9, ...로 순회한다. 짝수가 제외되므로 실행 횟수가 절반으로 줄어든다.
* 그런데 홀수가 짝수로 나누어질까? 아니다, 홀수는 짝수로 나뉘어지지 않는다. 즉, 나누는 수인 j 또한 짝수일 필요가 없으므로 아래와 같이 고쳐줄 수 있다.
<pre>
bool prime[100];
bool isPrime;
prime[2]=true;
for(i=3; i<n; i+=2){
        isPrime = true;
        for(j=3; j<=sqrt(i); j+=2){
            if(i%j==0) isPrime=false; 
        }
        prime[i]=isPrime;
}
</pre>
* 마지막 실행 횟수를 줄일 수 있는 팁은 아주 간단하다.
* 약수가 하나라도 있으면 소수가 아니다. 즉, 소수가 나온다면 바로 break를 걸어 준다. 
<pre>
bool prime[100];
bool isPrime;
prime[2]=true;
for(i=3; i<n; i+=2){
        isPrime = true;
        for(j=3; j<=sqrt(i); j+=2){
            if(i%j==0) {isPrime=false; break;} 
        }
        prime[i]=isPrime;
}
</pre>

